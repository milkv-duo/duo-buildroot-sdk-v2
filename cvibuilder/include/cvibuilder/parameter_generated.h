// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PARAMETER_CVI_CPU_OP_H_
#define FLATBUFFERS_GENERATED_PARAMETER_CVI_CPU_OP_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace cvi {
namespace cpu_op {

struct IntAttr;
struct IntAttrBuilder;

struct FloatAttr;
struct FloatAttrBuilder;

struct BoolAttr;
struct BoolAttrBuilder;

struct StrAttr;
struct StrAttrBuilder;

struct IntArrayAttr;
struct IntArrayAttrBuilder;

struct FloatArrayAttr;
struct FloatArrayAttrBuilder;

struct Attribute;
struct AttributeBuilder;

struct Parameter;
struct ParameterBuilder;

struct IntAttr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntAttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntAttrBuilder {
  typedef IntAttr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(IntAttr::VT_KEY, key);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(IntAttr::VT_VALUE, value, 0);
  }
  explicit IntAttrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntAttr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntAttr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntAttr> CreateIntAttr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    int32_t value = 0) {
  IntAttrBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntAttr> CreateIntAttrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return cvi::cpu_op::CreateIntAttr(
      _fbb,
      key__,
      value);
}

struct FloatAttr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatAttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct FloatAttrBuilder {
  typedef FloatAttr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(FloatAttr::VT_KEY, key);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(FloatAttr::VT_VALUE, value, 0.0f);
  }
  explicit FloatAttrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatAttr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatAttr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatAttr> CreateFloatAttr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    float value = 0.0f) {
  FloatAttrBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FloatAttr> CreateFloatAttrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    float value = 0.0f) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return cvi::cpu_op::CreateFloatAttr(
      _fbb,
      key__,
      value);
}

struct BoolAttr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolAttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BoolAttrBuilder {
  typedef BoolAttr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(BoolAttr::VT_KEY, key);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BoolAttr::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BoolAttrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolAttr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolAttr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolAttr> CreateBoolAttr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    bool value = false) {
  BoolAttrBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BoolAttr> CreateBoolAttrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    bool value = false) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return cvi::cpu_op::CreateBoolAttr(
      _fbb,
      key__,
      value);
}

struct StrAttr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StrAttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StrAttrBuilder {
  typedef StrAttr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(StrAttr::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StrAttr::VT_VALUE, value);
  }
  explicit StrAttrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StrAttr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StrAttr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StrAttr> CreateStrAttr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StrAttrBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StrAttr> CreateStrAttrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return cvi::cpu_op::CreateStrAttr(
      _fbb,
      key__,
      value__);
}

struct IntArrayAttr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntArrayAttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::Vector<int32_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct IntArrayAttrBuilder {
  typedef IntArrayAttr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(IntArrayAttr::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value) {
    fbb_.AddOffset(IntArrayAttr::VT_VALUE, value);
  }
  explicit IntArrayAttrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntArrayAttr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntArrayAttr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntArrayAttr> CreateIntArrayAttr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> value = 0) {
  IntArrayAttrBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntArrayAttr> CreateIntArrayAttrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<int32_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<int32_t>(*value) : 0;
  return cvi::cpu_op::CreateIntArrayAttr(
      _fbb,
      key__,
      value__);
}

struct FloatArrayAttr FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatArrayAttrBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::Vector<float> *value() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct FloatArrayAttrBuilder {
  typedef FloatArrayAttr Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(FloatArrayAttr::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(FloatArrayAttr::VT_VALUE, value);
  }
  explicit FloatArrayAttrBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatArrayAttr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatArrayAttr>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatArrayAttr> CreateFloatArrayAttr(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> value = 0) {
  FloatArrayAttrBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FloatArrayAttr> CreateFloatArrayAttrDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<float> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return cvi::cpu_op::CreateFloatArrayAttr(
      _fbb,
      key__,
      value__);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOAT_ATTR = 4,
    VT_BOOL_ATTR = 6,
    VT_INT_ATTR = 8,
    VT_STR_ATTR = 10,
    VT_FLOAT_ARRAY_ATTR = 12,
    VT_INT_ARRAY_ATTR = 14
  };
  const cvi::cpu_op::FloatAttr *float_attr() const {
    return GetPointer<const cvi::cpu_op::FloatAttr *>(VT_FLOAT_ATTR);
  }
  const cvi::cpu_op::BoolAttr *bool_attr() const {
    return GetPointer<const cvi::cpu_op::BoolAttr *>(VT_BOOL_ATTR);
  }
  const cvi::cpu_op::IntAttr *int_attr() const {
    return GetPointer<const cvi::cpu_op::IntAttr *>(VT_INT_ATTR);
  }
  const cvi::cpu_op::StrAttr *str_attr() const {
    return GetPointer<const cvi::cpu_op::StrAttr *>(VT_STR_ATTR);
  }
  const cvi::cpu_op::FloatArrayAttr *float_array_attr() const {
    return GetPointer<const cvi::cpu_op::FloatArrayAttr *>(VT_FLOAT_ARRAY_ATTR);
  }
  const cvi::cpu_op::IntArrayAttr *int_array_attr() const {
    return GetPointer<const cvi::cpu_op::IntArrayAttr *>(VT_INT_ARRAY_ATTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FLOAT_ATTR) &&
           verifier.VerifyTable(float_attr()) &&
           VerifyOffset(verifier, VT_BOOL_ATTR) &&
           verifier.VerifyTable(bool_attr()) &&
           VerifyOffset(verifier, VT_INT_ATTR) &&
           verifier.VerifyTable(int_attr()) &&
           VerifyOffset(verifier, VT_STR_ATTR) &&
           verifier.VerifyTable(str_attr()) &&
           VerifyOffset(verifier, VT_FLOAT_ARRAY_ATTR) &&
           verifier.VerifyTable(float_array_attr()) &&
           VerifyOffset(verifier, VT_INT_ARRAY_ATTR) &&
           verifier.VerifyTable(int_array_attr()) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_float_attr(::flatbuffers::Offset<cvi::cpu_op::FloatAttr> float_attr) {
    fbb_.AddOffset(Attribute::VT_FLOAT_ATTR, float_attr);
  }
  void add_bool_attr(::flatbuffers::Offset<cvi::cpu_op::BoolAttr> bool_attr) {
    fbb_.AddOffset(Attribute::VT_BOOL_ATTR, bool_attr);
  }
  void add_int_attr(::flatbuffers::Offset<cvi::cpu_op::IntAttr> int_attr) {
    fbb_.AddOffset(Attribute::VT_INT_ATTR, int_attr);
  }
  void add_str_attr(::flatbuffers::Offset<cvi::cpu_op::StrAttr> str_attr) {
    fbb_.AddOffset(Attribute::VT_STR_ATTR, str_attr);
  }
  void add_float_array_attr(::flatbuffers::Offset<cvi::cpu_op::FloatArrayAttr> float_array_attr) {
    fbb_.AddOffset(Attribute::VT_FLOAT_ARRAY_ATTR, float_array_attr);
  }
  void add_int_array_attr(::flatbuffers::Offset<cvi::cpu_op::IntArrayAttr> int_array_attr) {
    fbb_.AddOffset(Attribute::VT_INT_ARRAY_ATTR, int_array_attr);
  }
  explicit AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Attribute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Attribute> CreateAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<cvi::cpu_op::FloatAttr> float_attr = 0,
    ::flatbuffers::Offset<cvi::cpu_op::BoolAttr> bool_attr = 0,
    ::flatbuffers::Offset<cvi::cpu_op::IntAttr> int_attr = 0,
    ::flatbuffers::Offset<cvi::cpu_op::StrAttr> str_attr = 0,
    ::flatbuffers::Offset<cvi::cpu_op::FloatArrayAttr> float_array_attr = 0,
    ::flatbuffers::Offset<cvi::cpu_op::IntArrayAttr> int_array_attr = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_int_array_attr(int_array_attr);
  builder_.add_float_array_attr(float_array_attr);
  builder_.add_str_attr(str_attr);
  builder_.add_int_attr(int_attr);
  builder_.add_bool_attr(bool_attr);
  builder_.add_float_attr(float_attr);
  return builder_.Finish();
}

struct Parameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTRIBUTES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<cvi::cpu_op::Attribute>> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<cvi::cpu_op::Attribute>> *>(VT_ATTRIBUTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct ParameterBuilder {
  typedef Parameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<cvi::cpu_op::Attribute>>> attributes) {
    fbb_.AddOffset(Parameter::VT_ATTRIBUTES, attributes);
  }
  explicit ParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Parameter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Parameter> CreateParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<cvi::cpu_op::Attribute>>> attributes = 0) {
  ParameterBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Parameter> CreateParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<cvi::cpu_op::Attribute>> *attributes = nullptr) {
  auto attributes__ = attributes ? _fbb.CreateVector<::flatbuffers::Offset<cvi::cpu_op::Attribute>>(*attributes) : 0;
  return cvi::cpu_op::CreateParameter(
      _fbb,
      attributes__);
}

inline const cvi::cpu_op::Parameter *GetParameter(const void *buf) {
  return ::flatbuffers::GetRoot<cvi::cpu_op::Parameter>(buf);
}

inline const cvi::cpu_op::Parameter *GetSizePrefixedParameter(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<cvi::cpu_op::Parameter>(buf);
}

inline bool VerifyParameterBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cvi::cpu_op::Parameter>(nullptr);
}

inline bool VerifySizePrefixedParameterBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cvi::cpu_op::Parameter>(nullptr);
}

inline void FinishParameterBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<cvi::cpu_op::Parameter> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedParameterBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<cvi::cpu_op::Parameter> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace cpu_op
}  // namespace cvi

#endif  // FLATBUFFERS_GENERATED_PARAMETER_CVI_CPU_OP_H_
